# coding: utf-8

"""
    AVACloud API 1.52.1

    AVACloud API specification  # noqa: E501

    OpenAPI spec version: 1.52.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from avacloud_client_python.configuration import Configuration


class PositionDto(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'unit_price': 'float',
        'unit_price_override': 'float',
        'quantity': 'float',
        'quantity_override': 'float',
        'is_complementing_position': 'bool',
        'complements_positions': 'list[str]',
        'complementing_price_percentage_override': 'float',
        'complementing_price_percentage': 'float',
        'unit_tag': 'str',
        'labour_components': 'LabourPriceComponentDto',
        'price_components': 'list[PriceComponentDto]',
        'quantity_components': 'list[CalculationDto]',
        'sub_descriptions': 'list[SubDescriptionDto]',
        'comission_status': 'ComissionStatusDto',
        'complemented_by': 'list[str]',
        'complemented': 'bool',
        'amount_to_be_entered_by_bidder': 'bool',
        'price_composition_required': 'bool',
        'use_different_tax_rate': 'bool',
        'tax_rate': 'float',
        'item_number': 'ItemNumberDto',
        'deduction_factor': 'float',
        'total_price': 'float',
        'total_price_gross': 'float',
        'total_price_gross_deducted': 'float',
        'deducted_price': 'float',
        'position_type': 'PositionTypeDto',
        'price_type': 'PriceTypeDto',
        'service_type': 'ServiceTypeDto',
        'product_data': 'ProductDataDto',
        'short_text': 'str',
        'long_text': 'str',
        'html_long_text': 'str',
        'addition_type': 'AdditionTypeDto',
        'element_type': 'str',
        'quantity_assignments': 'list[QuantityAssignmentDto]',
        'commerce_properties': 'CommercePropertiesDto',
        'alternative_to': 'str',
        'alternative_identifier': 'int',
        'alternative_group_identifier': 'int',
        'is_lump_sum': 'bool',
        'repetition_to': 'str',
        'standardized_description': 'StandardizedDescriptionDto',
        'complemented_by_quantities': 'list[ComplementedByQuantityDto]',
        'execution_description_reference': 'str',
        'not_offered': 'bool',
        'oenorm_position_properties': 'OenormPositionPropertiesDto',
        'description_id': 'str',
        'hierarchy_level': 'int',
        'addendum_status': 'AddendumStatusDto',
        'has_bidder_comment_in_html_long_text': 'bool',
        'gaeb_complementing_type': 'PositionComplementingTypeDto',
        'hold_out_properties': 'PositionHoldOutPropertiesDto',
        'estimated_quantity': 'float',
        'price_catalogue_data': 'PriceCatalogueDataDto',
        'ignore_project_catalogue_propagation': 'bool'
    }

    attribute_map = {
        'unit_price': 'unitPrice',
        'unit_price_override': 'unitPriceOverride',
        'quantity': 'quantity',
        'quantity_override': 'quantityOverride',
        'is_complementing_position': 'isComplementingPosition',
        'complements_positions': 'complementsPositions',
        'complementing_price_percentage_override': 'complementingPricePercentageOverride',
        'complementing_price_percentage': 'complementingPricePercentage',
        'unit_tag': 'unitTag',
        'labour_components': 'labourComponents',
        'price_components': 'priceComponents',
        'quantity_components': 'quantityComponents',
        'sub_descriptions': 'subDescriptions',
        'comission_status': 'comissionStatus',
        'complemented_by': 'complementedBy',
        'complemented': 'complemented',
        'amount_to_be_entered_by_bidder': 'amountToBeEnteredByBidder',
        'price_composition_required': 'priceCompositionRequired',
        'use_different_tax_rate': 'useDifferentTaxRate',
        'tax_rate': 'taxRate',
        'item_number': 'itemNumber',
        'deduction_factor': 'deductionFactor',
        'total_price': 'totalPrice',
        'total_price_gross': 'totalPriceGross',
        'total_price_gross_deducted': 'totalPriceGrossDeducted',
        'deducted_price': 'deductedPrice',
        'position_type': 'positionType',
        'price_type': 'priceType',
        'service_type': 'serviceType',
        'product_data': 'productData',
        'short_text': 'shortText',
        'long_text': 'longText',
        'html_long_text': 'htmlLongText',
        'addition_type': 'additionType',
        'element_type': 'elementType',
        'quantity_assignments': 'quantityAssignments',
        'commerce_properties': 'commerceProperties',
        'alternative_to': 'alternativeTo',
        'alternative_identifier': 'alternativeIdentifier',
        'alternative_group_identifier': 'alternativeGroupIdentifier',
        'is_lump_sum': 'isLumpSum',
        'repetition_to': 'repetitionTo',
        'standardized_description': 'standardizedDescription',
        'complemented_by_quantities': 'complementedByQuantities',
        'execution_description_reference': 'executionDescriptionReference',
        'not_offered': 'notOffered',
        'oenorm_position_properties': 'oenormPositionProperties',
        'description_id': 'descriptionId',
        'hierarchy_level': 'hierarchyLevel',
        'addendum_status': 'addendumStatus',
        'has_bidder_comment_in_html_long_text': 'hasBidderCommentInHtmlLongText',
        'gaeb_complementing_type': 'gaebComplementingType',
        'hold_out_properties': 'holdOutProperties',
        'estimated_quantity': 'estimatedQuantity',
        'price_catalogue_data': 'priceCatalogueData',
        'ignore_project_catalogue_propagation': 'ignoreProjectCataloguePropagation'
    }

    def __init__(self, unit_price=None, unit_price_override=None, quantity=None, quantity_override=None, is_complementing_position=None, complements_positions=None, complementing_price_percentage_override=None, complementing_price_percentage=None, unit_tag=None, labour_components=None, price_components=None, quantity_components=None, sub_descriptions=None, comission_status=None, complemented_by=None, complemented=None, amount_to_be_entered_by_bidder=None, price_composition_required=None, use_different_tax_rate=None, tax_rate=None, item_number=None, deduction_factor=None, total_price=None, total_price_gross=None, total_price_gross_deducted=None, deducted_price=None, position_type=None, price_type=None, service_type=None, product_data=None, short_text=None, long_text=None, html_long_text=None, addition_type=None, element_type=None, quantity_assignments=None, commerce_properties=None, alternative_to=None, alternative_identifier=None, alternative_group_identifier=None, is_lump_sum=None, repetition_to=None, standardized_description=None, complemented_by_quantities=None, execution_description_reference=None, not_offered=None, oenorm_position_properties=None, description_id=None, hierarchy_level=None, addendum_status=None, has_bidder_comment_in_html_long_text=None, gaeb_complementing_type=None, hold_out_properties=None, estimated_quantity=None, price_catalogue_data=None, ignore_project_catalogue_propagation=None, _configuration=None):  # noqa: E501
        """PositionDto - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._unit_price = None
        self._unit_price_override = None
        self._quantity = None
        self._quantity_override = None
        self._is_complementing_position = None
        self._complements_positions = None
        self._complementing_price_percentage_override = None
        self._complementing_price_percentage = None
        self._unit_tag = None
        self._labour_components = None
        self._price_components = None
        self._quantity_components = None
        self._sub_descriptions = None
        self._comission_status = None
        self._complemented_by = None
        self._complemented = None
        self._amount_to_be_entered_by_bidder = None
        self._price_composition_required = None
        self._use_different_tax_rate = None
        self._tax_rate = None
        self._item_number = None
        self._deduction_factor = None
        self._total_price = None
        self._total_price_gross = None
        self._total_price_gross_deducted = None
        self._deducted_price = None
        self._position_type = None
        self._price_type = None
        self._service_type = None
        self._product_data = None
        self._short_text = None
        self._long_text = None
        self._html_long_text = None
        self._addition_type = None
        self._element_type = None
        self._quantity_assignments = None
        self._commerce_properties = None
        self._alternative_to = None
        self._alternative_identifier = None
        self._alternative_group_identifier = None
        self._is_lump_sum = None
        self._repetition_to = None
        self._standardized_description = None
        self._complemented_by_quantities = None
        self._execution_description_reference = None
        self._not_offered = None
        self._oenorm_position_properties = None
        self._description_id = None
        self._hierarchy_level = None
        self._addendum_status = None
        self._has_bidder_comment_in_html_long_text = None
        self._gaeb_complementing_type = None
        self._hold_out_properties = None
        self._estimated_quantity = None
        self._price_catalogue_data = None
        self._ignore_project_catalogue_propagation = None
        self.discriminator = None

        self.unit_price = unit_price
        if unit_price_override is not None:
            self.unit_price_override = unit_price_override
        self.quantity = quantity
        if quantity_override is not None:
            self.quantity_override = quantity_override
        self.is_complementing_position = is_complementing_position
        if complements_positions is not None:
            self.complements_positions = complements_positions
        if complementing_price_percentage_override is not None:
            self.complementing_price_percentage_override = complementing_price_percentage_override
        if complementing_price_percentage is not None:
            self.complementing_price_percentage = complementing_price_percentage
        if unit_tag is not None:
            self.unit_tag = unit_tag
        if labour_components is not None:
            self.labour_components = labour_components
        if price_components is not None:
            self.price_components = price_components
        if quantity_components is not None:
            self.quantity_components = quantity_components
        if sub_descriptions is not None:
            self.sub_descriptions = sub_descriptions
        self.comission_status = comission_status
        if complemented_by is not None:
            self.complemented_by = complemented_by
        self.complemented = complemented
        self.amount_to_be_entered_by_bidder = amount_to_be_entered_by_bidder
        self.price_composition_required = price_composition_required
        self.use_different_tax_rate = use_different_tax_rate
        self.tax_rate = tax_rate
        if item_number is not None:
            self.item_number = item_number
        self.deduction_factor = deduction_factor
        self.total_price = total_price
        self.total_price_gross = total_price_gross
        self.total_price_gross_deducted = total_price_gross_deducted
        self.deducted_price = deducted_price
        self.position_type = position_type
        self.price_type = price_type
        self.service_type = service_type
        if product_data is not None:
            self.product_data = product_data
        if short_text is not None:
            self.short_text = short_text
        if long_text is not None:
            self.long_text = long_text
        if html_long_text is not None:
            self.html_long_text = html_long_text
        self.addition_type = addition_type
        if element_type is not None:
            self.element_type = element_type
        if quantity_assignments is not None:
            self.quantity_assignments = quantity_assignments
        if commerce_properties is not None:
            self.commerce_properties = commerce_properties
        if alternative_to is not None:
            self.alternative_to = alternative_to
        if alternative_identifier is not None:
            self.alternative_identifier = alternative_identifier
        if alternative_group_identifier is not None:
            self.alternative_group_identifier = alternative_group_identifier
        self.is_lump_sum = is_lump_sum
        if repetition_to is not None:
            self.repetition_to = repetition_to
        if standardized_description is not None:
            self.standardized_description = standardized_description
        if complemented_by_quantities is not None:
            self.complemented_by_quantities = complemented_by_quantities
        if execution_description_reference is not None:
            self.execution_description_reference = execution_description_reference
        self.not_offered = not_offered
        if oenorm_position_properties is not None:
            self.oenorm_position_properties = oenorm_position_properties
        if description_id is not None:
            self.description_id = description_id
        self.hierarchy_level = hierarchy_level
        if addendum_status is not None:
            self.addendum_status = addendum_status
        self.has_bidder_comment_in_html_long_text = has_bidder_comment_in_html_long_text
        self.gaeb_complementing_type = gaeb_complementing_type
        if hold_out_properties is not None:
            self.hold_out_properties = hold_out_properties
        if estimated_quantity is not None:
            self.estimated_quantity = estimated_quantity
        if price_catalogue_data is not None:
            self.price_catalogue_data = price_catalogue_data
        self.ignore_project_catalogue_propagation = ignore_project_catalogue_propagation

    @property
    def unit_price(self):
        """Gets the unit_price of this PositionDto.  # noqa: E501

        Will return the price per unit, rounded according to the project settings or the default value of three decimal places  # noqa: E501

        :return: The unit_price of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._unit_price

    @unit_price.setter
    def unit_price(self, unit_price):
        """Sets the unit_price of this PositionDto.

        Will return the price per unit, rounded according to the project settings or the default value of three decimal places  # noqa: E501

        :param unit_price: The unit_price of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and unit_price is None:
            raise ValueError("Invalid value for `unit_price`, must not be `None`")  # noqa: E501

        self._unit_price = unit_price

    @property
    def unit_price_override(self):
        """Gets the unit_price_override of this PositionDto.  # noqa: E501

        You can use this property to directly set the unit price for this position. This will override any given PriceComponents  # noqa: E501

        :return: The unit_price_override of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._unit_price_override

    @unit_price_override.setter
    def unit_price_override(self, unit_price_override):
        """Sets the unit_price_override of this PositionDto.

        You can use this property to directly set the unit price for this position. This will override any given PriceComponents  # noqa: E501

        :param unit_price_override: The unit_price_override of this PositionDto.  # noqa: E501
        :type: float
        """

        self._unit_price_override = unit_price_override

    @property
    def quantity(self):
        """Gets the quantity of this PositionDto.  # noqa: E501

        Will return this Position's total quantity, rounded to three decimal places.  # noqa: E501

        :return: The quantity of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity):
        """Sets the quantity of this PositionDto.

        Will return this Position's total quantity, rounded to three decimal places.  # noqa: E501

        :param quantity: The quantity of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and quantity is None:
            raise ValueError("Invalid value for `quantity`, must not be `None`")  # noqa: E501

        self._quantity = quantity

    @property
    def quantity_override(self):
        """Gets the quantity_override of this PositionDto.  # noqa: E501

        You can use this property to directly set the quantity for this position. This will override any given QuantityComponents  # noqa: E501

        :return: The quantity_override of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._quantity_override

    @quantity_override.setter
    def quantity_override(self, quantity_override):
        """Sets the quantity_override of this PositionDto.

        You can use this property to directly set the quantity for this position. This will override any given QuantityComponents  # noqa: E501

        :param quantity_override: The quantity_override of this PositionDto.  # noqa: E501
        :type: float
        """

        self._quantity_override = quantity_override

    @property
    def is_complementing_position(self):
        """Gets the is_complementing_position of this PositionDto.  # noqa: E501

        This indicates true if this specific position is specified as a complementing position for any base position.  # noqa: E501

        :return: The is_complementing_position of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._is_complementing_position

    @is_complementing_position.setter
    def is_complementing_position(self, is_complementing_position):
        """Sets the is_complementing_position of this PositionDto.

        This indicates true if this specific position is specified as a complementing position for any base position.  # noqa: E501

        :param is_complementing_position: The is_complementing_position of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and is_complementing_position is None:
            raise ValueError("Invalid value for `is_complementing_position`, must not be `None`")  # noqa: E501

        self._is_complementing_position = is_complementing_position

    @property
    def complements_positions(self):
        """Gets the complements_positions of this PositionDto.  # noqa: E501

        If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position.  # noqa: E501

        :return: The complements_positions of this PositionDto.  # noqa: E501
        :rtype: list[str]
        """
        return self._complements_positions

    @complements_positions.setter
    def complements_positions(self, complements_positions):
        """Sets the complements_positions of this PositionDto.

        If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position.  # noqa: E501

        :param complements_positions: The complements_positions of this PositionDto.  # noqa: E501
        :type: list[str]
        """

        self._complements_positions = complements_positions

    @property
    def complementing_price_percentage_override(self):
        """Gets the complementing_price_percentage_override of this PositionDto.  # noqa: E501

        You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride.  # noqa: E501

        :return: The complementing_price_percentage_override of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._complementing_price_percentage_override

    @complementing_price_percentage_override.setter
    def complementing_price_percentage_override(self, complementing_price_percentage_override):
        """Sets the complementing_price_percentage_override of this PositionDto.

        You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride.  # noqa: E501

        :param complementing_price_percentage_override: The complementing_price_percentage_override of this PositionDto.  # noqa: E501
        :type: float
        """

        self._complementing_price_percentage_override = complementing_price_percentage_override

    @property
    def complementing_price_percentage(self):
        """Gets the complementing_price_percentage of this PositionDto.  # noqa: E501

        This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null.  # noqa: E501

        :return: The complementing_price_percentage of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._complementing_price_percentage

    @complementing_price_percentage.setter
    def complementing_price_percentage(self, complementing_price_percentage):
        """Sets the complementing_price_percentage of this PositionDto.

        This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null.  # noqa: E501

        :param complementing_price_percentage: The complementing_price_percentage of this PositionDto.  # noqa: E501
        :type: float
        """

        self._complementing_price_percentage = complementing_price_percentage

    @property
    def unit_tag(self):
        """Gets the unit_tag of this PositionDto.  # noqa: E501

        The tag of the unit used for this positions quantity.  # noqa: E501

        :return: The unit_tag of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._unit_tag

    @unit_tag.setter
    def unit_tag(self, unit_tag):
        """Sets the unit_tag of this PositionDto.

        The tag of the unit used for this positions quantity.  # noqa: E501

        :param unit_tag: The unit_tag of this PositionDto.  # noqa: E501
        :type: str
        """

        self._unit_tag = unit_tag

    @property
    def labour_components(self):
        """Gets the labour_components of this PositionDto.  # noqa: E501

        The components for labour time in this Position.  # noqa: E501

        :return: The labour_components of this PositionDto.  # noqa: E501
        :rtype: LabourPriceComponentDto
        """
        return self._labour_components

    @labour_components.setter
    def labour_components(self, labour_components):
        """Sets the labour_components of this PositionDto.

        The components for labour time in this Position.  # noqa: E501

        :param labour_components: The labour_components of this PositionDto.  # noqa: E501
        :type: LabourPriceComponentDto
        """

        self._labour_components = labour_components

    @property
    def price_components(self):
        """Gets the price_components of this PositionDto.  # noqa: E501

        The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.  # noqa: E501

        :return: The price_components of this PositionDto.  # noqa: E501
        :rtype: list[PriceComponentDto]
        """
        return self._price_components

    @price_components.setter
    def price_components(self, price_components):
        """Sets the price_components of this PositionDto.

        The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.  # noqa: E501

        :param price_components: The price_components of this PositionDto.  # noqa: E501
        :type: list[PriceComponentDto]
        """

        self._price_components = price_components

    @property
    def quantity_components(self):
        """Gets the quantity_components of this PositionDto.  # noqa: E501

        The quantity components of this Position.  # noqa: E501

        :return: The quantity_components of this PositionDto.  # noqa: E501
        :rtype: list[CalculationDto]
        """
        return self._quantity_components

    @quantity_components.setter
    def quantity_components(self, quantity_components):
        """Sets the quantity_components of this PositionDto.

        The quantity components of this Position.  # noqa: E501

        :param quantity_components: The quantity_components of this PositionDto.  # noqa: E501
        :type: list[CalculationDto]
        """

        self._quantity_components = quantity_components

    @property
    def sub_descriptions(self):
        """Gets the sub_descriptions of this PositionDto.  # noqa: E501

        Further structuring of this Position.  # noqa: E501

        :return: The sub_descriptions of this PositionDto.  # noqa: E501
        :rtype: list[SubDescriptionDto]
        """
        return self._sub_descriptions

    @sub_descriptions.setter
    def sub_descriptions(self, sub_descriptions):
        """Sets the sub_descriptions of this PositionDto.

        Further structuring of this Position.  # noqa: E501

        :param sub_descriptions: The sub_descriptions of this PositionDto.  # noqa: E501
        :type: list[SubDescriptionDto]
        """

        self._sub_descriptions = sub_descriptions

    @property
    def comission_status(self):
        """Gets the comission_status of this PositionDto.  # noqa: E501

        Indicates the status of this Position's comission.  # noqa: E501

        :return: The comission_status of this PositionDto.  # noqa: E501
        :rtype: ComissionStatusDto
        """
        return self._comission_status

    @comission_status.setter
    def comission_status(self, comission_status):
        """Sets the comission_status of this PositionDto.

        Indicates the status of this Position's comission.  # noqa: E501

        :param comission_status: The comission_status of this PositionDto.  # noqa: E501
        :type: ComissionStatusDto
        """
        if self._configuration.client_side_validation and comission_status is None:
            raise ValueError("Invalid value for `comission_status`, must not be `None`")  # noqa: E501

        self._comission_status = comission_status

    @property
    def complemented_by(self):
        """Gets the complemented_by of this PositionDto.  # noqa: E501

        A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.  # noqa: E501

        :return: The complemented_by of this PositionDto.  # noqa: E501
        :rtype: list[str]
        """
        return self._complemented_by

    @complemented_by.setter
    def complemented_by(self, complemented_by):
        """Sets the complemented_by of this PositionDto.

        A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.  # noqa: E501

        :param complemented_by: The complemented_by of this PositionDto.  # noqa: E501
        :type: list[str]
        """

        self._complemented_by = complemented_by

    @property
    def complemented(self):
        """Gets the complemented of this PositionDto.  # noqa: E501

        Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.  # noqa: E501

        :return: The complemented of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._complemented

    @complemented.setter
    def complemented(self, complemented):
        """Sets the complemented of this PositionDto.

        Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.  # noqa: E501

        :param complemented: The complemented of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and complemented is None:
            raise ValueError("Invalid value for `complemented`, must not be `None`")  # noqa: E501

        self._complemented = complemented

    @property
    def amount_to_be_entered_by_bidder(self):
        """Gets the amount_to_be_entered_by_bidder of this PositionDto.  # noqa: E501

        Indicates that the amount for this Position is to be set by the bidder.  # noqa: E501

        :return: The amount_to_be_entered_by_bidder of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._amount_to_be_entered_by_bidder

    @amount_to_be_entered_by_bidder.setter
    def amount_to_be_entered_by_bidder(self, amount_to_be_entered_by_bidder):
        """Sets the amount_to_be_entered_by_bidder of this PositionDto.

        Indicates that the amount for this Position is to be set by the bidder.  # noqa: E501

        :param amount_to_be_entered_by_bidder: The amount_to_be_entered_by_bidder of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and amount_to_be_entered_by_bidder is None:
            raise ValueError("Invalid value for `amount_to_be_entered_by_bidder`, must not be `None`")  # noqa: E501

        self._amount_to_be_entered_by_bidder = amount_to_be_entered_by_bidder

    @property
    def price_composition_required(self):
        """Gets the price_composition_required of this PositionDto.  # noqa: E501

        Indicates if the bidder demands for prices to be broken up into their price components.  # noqa: E501

        :return: The price_composition_required of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._price_composition_required

    @price_composition_required.setter
    def price_composition_required(self, price_composition_required):
        """Sets the price_composition_required of this PositionDto.

        Indicates if the bidder demands for prices to be broken up into their price components.  # noqa: E501

        :param price_composition_required: The price_composition_required of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and price_composition_required is None:
            raise ValueError("Invalid value for `price_composition_required`, must not be `None`")  # noqa: E501

        self._price_composition_required = price_composition_required

    @property
    def use_different_tax_rate(self):
        """Gets the use_different_tax_rate of this PositionDto.  # noqa: E501

        Indicates if this Position should use a different TaxRate than what is the default for the Project.  # noqa: E501

        :return: The use_different_tax_rate of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._use_different_tax_rate

    @use_different_tax_rate.setter
    def use_different_tax_rate(self, use_different_tax_rate):
        """Sets the use_different_tax_rate of this PositionDto.

        Indicates if this Position should use a different TaxRate than what is the default for the Project.  # noqa: E501

        :param use_different_tax_rate: The use_different_tax_rate of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and use_different_tax_rate is None:
            raise ValueError("Invalid value for `use_different_tax_rate`, must not be `None`")  # noqa: E501

        self._use_different_tax_rate = use_different_tax_rate

    @property
    def tax_rate(self):
        """Gets the tax_rate of this PositionDto.  # noqa: E501

        Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)  # noqa: E501

        :return: The tax_rate of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._tax_rate

    @tax_rate.setter
    def tax_rate(self, tax_rate):
        """Sets the tax_rate of this PositionDto.

        Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)  # noqa: E501

        :param tax_rate: The tax_rate of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and tax_rate is None:
            raise ValueError("Invalid value for `tax_rate`, must not be `None`")  # noqa: E501

        self._tax_rate = tax_rate

    @property
    def item_number(self):
        """Gets the item_number of this PositionDto.  # noqa: E501

        The ItemNumber for this Position.  # noqa: E501

        :return: The item_number of this PositionDto.  # noqa: E501
        :rtype: ItemNumberDto
        """
        return self._item_number

    @item_number.setter
    def item_number(self, item_number):
        """Sets the item_number of this PositionDto.

        The ItemNumber for this Position.  # noqa: E501

        :param item_number: The item_number of this PositionDto.  # noqa: E501
        :type: ItemNumberDto
        """

        self._item_number = item_number

    @property
    def deduction_factor(self):
        """Gets the deduction_factor of this PositionDto.  # noqa: E501

        The rate of deductions, i.e. 0.12m means 12% price deduction.  # noqa: E501

        :return: The deduction_factor of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._deduction_factor

    @deduction_factor.setter
    def deduction_factor(self, deduction_factor):
        """Sets the deduction_factor of this PositionDto.

        The rate of deductions, i.e. 0.12m means 12% price deduction.  # noqa: E501

        :param deduction_factor: The deduction_factor of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and deduction_factor is None:
            raise ValueError("Invalid value for `deduction_factor`, must not be `None`")  # noqa: E501

        self._deduction_factor = deduction_factor

    @property
    def total_price(self):
        """Gets the total_price of this PositionDto.  # noqa: E501

        Returns the product of UnitPrice times Quantity.  # noqa: E501

        :return: The total_price of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._total_price

    @total_price.setter
    def total_price(self, total_price):
        """Sets the total_price of this PositionDto.

        Returns the product of UnitPrice times Quantity.  # noqa: E501

        :param total_price: The total_price of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and total_price is None:
            raise ValueError("Invalid value for `total_price`, must not be `None`")  # noqa: E501

        self._total_price = total_price

    @property
    def total_price_gross(self):
        """Gets the total_price_gross of this PositionDto.  # noqa: E501

        The total gross price for this Position.  # noqa: E501

        :return: The total_price_gross of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._total_price_gross

    @total_price_gross.setter
    def total_price_gross(self, total_price_gross):
        """Sets the total_price_gross of this PositionDto.

        The total gross price for this Position.  # noqa: E501

        :param total_price_gross: The total_price_gross of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and total_price_gross is None:
            raise ValueError("Invalid value for `total_price_gross`, must not be `None`")  # noqa: E501

        self._total_price_gross = total_price_gross

    @property
    def total_price_gross_deducted(self):
        """Gets the total_price_gross_deducted of this PositionDto.  # noqa: E501

        Total gross price after applied deductions.  # noqa: E501

        :return: The total_price_gross_deducted of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._total_price_gross_deducted

    @total_price_gross_deducted.setter
    def total_price_gross_deducted(self, total_price_gross_deducted):
        """Sets the total_price_gross_deducted of this PositionDto.

        Total gross price after applied deductions.  # noqa: E501

        :param total_price_gross_deducted: The total_price_gross_deducted of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and total_price_gross_deducted is None:
            raise ValueError("Invalid value for `total_price_gross_deducted`, must not be `None`")  # noqa: E501

        self._total_price_gross_deducted = total_price_gross_deducted

    @property
    def deducted_price(self):
        """Gets the deducted_price of this PositionDto.  # noqa: E501

        Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.  # noqa: E501

        :return: The deducted_price of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._deducted_price

    @deducted_price.setter
    def deducted_price(self, deducted_price):
        """Sets the deducted_price of this PositionDto.

        Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.  # noqa: E501

        :param deducted_price: The deducted_price of this PositionDto.  # noqa: E501
        :type: float
        """
        if self._configuration.client_side_validation and deducted_price is None:
            raise ValueError("Invalid value for `deducted_price`, must not be `None`")  # noqa: E501

        self._deducted_price = deducted_price

    @property
    def position_type(self):
        """Gets the position_type of this PositionDto.  # noqa: E501

        This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace.  # noqa: E501

        :return: The position_type of this PositionDto.  # noqa: E501
        :rtype: PositionTypeDto
        """
        return self._position_type

    @position_type.setter
    def position_type(self, position_type):
        """Sets the position_type of this PositionDto.

        This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace.  # noqa: E501

        :param position_type: The position_type of this PositionDto.  # noqa: E501
        :type: PositionTypeDto
        """
        if self._configuration.client_side_validation and position_type is None:
            raise ValueError("Invalid value for `position_type`, must not be `None`")  # noqa: E501

        self._position_type = position_type

    @property
    def price_type(self):
        """Gets the price_type of this PositionDto.  # noqa: E501

        Indicates the PriceType of this Position.  # noqa: E501

        :return: The price_type of this PositionDto.  # noqa: E501
        :rtype: PriceTypeDto
        """
        return self._price_type

    @price_type.setter
    def price_type(self, price_type):
        """Sets the price_type of this PositionDto.

        Indicates the PriceType of this Position.  # noqa: E501

        :param price_type: The price_type of this PositionDto.  # noqa: E501
        :type: PriceTypeDto
        """
        if self._configuration.client_side_validation and price_type is None:
            raise ValueError("Invalid value for `price_type`, must not be `None`")  # noqa: E501

        self._price_type = price_type

    @property
    def service_type(self):
        """Gets the service_type of this PositionDto.  # noqa: E501

        This indicates if this position is regular or describing a labour / hourly paid work service  # noqa: E501

        :return: The service_type of this PositionDto.  # noqa: E501
        :rtype: ServiceTypeDto
        """
        return self._service_type

    @service_type.setter
    def service_type(self, service_type):
        """Sets the service_type of this PositionDto.

        This indicates if this position is regular or describing a labour / hourly paid work service  # noqa: E501

        :param service_type: The service_type of this PositionDto.  # noqa: E501
        :type: ServiceTypeDto
        """
        if self._configuration.client_side_validation and service_type is None:
            raise ValueError("Invalid value for `service_type`, must not be `None`")  # noqa: E501

        self._service_type = service_type

    @property
    def product_data(self):
        """Gets the product_data of this PositionDto.  # noqa: E501

        This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles.  # noqa: E501

        :return: The product_data of this PositionDto.  # noqa: E501
        :rtype: ProductDataDto
        """
        return self._product_data

    @product_data.setter
    def product_data(self, product_data):
        """Sets the product_data of this PositionDto.

        This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles.  # noqa: E501

        :param product_data: The product_data of this PositionDto.  # noqa: E501
        :type: ProductDataDto
        """

        self._product_data = product_data

    @property
    def short_text(self):
        """Gets the short_text of this PositionDto.  # noqa: E501

        Short description for this DescriptionBase element.  # noqa: E501

        :return: The short_text of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._short_text

    @short_text.setter
    def short_text(self, short_text):
        """Sets the short_text of this PositionDto.

        Short description for this DescriptionBase element.  # noqa: E501

        :param short_text: The short_text of this PositionDto.  # noqa: E501
        :type: str
        """

        self._short_text = short_text

    @property
    def long_text(self):
        """Gets the long_text of this PositionDto.  # noqa: E501

        Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.  # noqa: E501

        :return: The long_text of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._long_text

    @long_text.setter
    def long_text(self, long_text):
        """Sets the long_text of this PositionDto.

        Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.  # noqa: E501

        :param long_text: The long_text of this PositionDto.  # noqa: E501
        :type: str
        """

        self._long_text = long_text

    @property
    def html_long_text(self):
        """Gets the html_long_text of this PositionDto.  # noqa: E501

        This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.  # noqa: E501

        :return: The html_long_text of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._html_long_text

    @html_long_text.setter
    def html_long_text(self, html_long_text):
        """Sets the html_long_text of this PositionDto.

        This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.  # noqa: E501

        :param html_long_text: The html_long_text of this PositionDto.  # noqa: E501
        :type: str
        """

        self._html_long_text = html_long_text

    @property
    def addition_type(self):
        """Gets the addition_type of this PositionDto.  # noqa: E501

        Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.  # noqa: E501

        :return: The addition_type of this PositionDto.  # noqa: E501
        :rtype: AdditionTypeDto
        """
        return self._addition_type

    @addition_type.setter
    def addition_type(self, addition_type):
        """Sets the addition_type of this PositionDto.

        Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text.  # noqa: E501

        :param addition_type: The addition_type of this PositionDto.  # noqa: E501
        :type: AdditionTypeDto
        """
        if self._configuration.client_side_validation and addition_type is None:
            raise ValueError("Invalid value for `addition_type`, must not be `None`")  # noqa: E501

        self._addition_type = addition_type

    @property
    def element_type(self):
        """Gets the element_type of this PositionDto.  # noqa: E501


        :return: The element_type of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._element_type

    @element_type.setter
    def element_type(self, element_type):
        """Sets the element_type of this PositionDto.


        :param element_type: The element_type of this PositionDto.  # noqa: E501
        :type: str
        """

        self._element_type = element_type

    @property
    def quantity_assignments(self):
        """Gets the quantity_assignments of this PositionDto.  # noqa: E501

        Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.  # noqa: E501

        :return: The quantity_assignments of this PositionDto.  # noqa: E501
        :rtype: list[QuantityAssignmentDto]
        """
        return self._quantity_assignments

    @quantity_assignments.setter
    def quantity_assignments(self, quantity_assignments):
        """Sets the quantity_assignments of this PositionDto.

        Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.  # noqa: E501

        :param quantity_assignments: The quantity_assignments of this PositionDto.  # noqa: E501
        :type: list[QuantityAssignmentDto]
        """

        self._quantity_assignments = quantity_assignments

    @property
    def commerce_properties(self):
        """Gets the commerce_properties of this PositionDto.  # noqa: E501

        The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information.  # noqa: E501

        :return: The commerce_properties of this PositionDto.  # noqa: E501
        :rtype: CommercePropertiesDto
        """
        return self._commerce_properties

    @commerce_properties.setter
    def commerce_properties(self, commerce_properties):
        """Sets the commerce_properties of this PositionDto.

        The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information.  # noqa: E501

        :param commerce_properties: The commerce_properties of this PositionDto.  # noqa: E501
        :type: CommercePropertiesDto
        """

        self._commerce_properties = commerce_properties

    @property
    def alternative_to(self):
        """Gets the alternative_to of this PositionDto.  # noqa: E501

        If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.  # noqa: E501

        :return: The alternative_to of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._alternative_to

    @alternative_to.setter
    def alternative_to(self, alternative_to):
        """Sets the alternative_to of this PositionDto.

        If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.  # noqa: E501

        :param alternative_to: The alternative_to of this PositionDto.  # noqa: E501
        :type: str
        """

        self._alternative_to = alternative_to

    @property
    def alternative_identifier(self):
        """Gets the alternative_identifier of this PositionDto.  # noqa: E501

        This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.  # noqa: E501

        :return: The alternative_identifier of this PositionDto.  # noqa: E501
        :rtype: int
        """
        return self._alternative_identifier

    @alternative_identifier.setter
    def alternative_identifier(self, alternative_identifier):
        """Sets the alternative_identifier of this PositionDto.

        This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.  # noqa: E501

        :param alternative_identifier: The alternative_identifier of this PositionDto.  # noqa: E501
        :type: int
        """

        self._alternative_identifier = alternative_identifier

    @property
    def alternative_group_identifier(self):
        """Gets the alternative_group_identifier of this PositionDto.  # noqa: E501

        This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.  # noqa: E501

        :return: The alternative_group_identifier of this PositionDto.  # noqa: E501
        :rtype: int
        """
        return self._alternative_group_identifier

    @alternative_group_identifier.setter
    def alternative_group_identifier(self, alternative_group_identifier):
        """Sets the alternative_group_identifier of this PositionDto.

        This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.  # noqa: E501

        :param alternative_group_identifier: The alternative_group_identifier of this PositionDto.  # noqa: E501
        :type: int
        """

        self._alternative_group_identifier = alternative_group_identifier

    @property
    def is_lump_sum(self):
        """Gets the is_lump_sum of this PositionDto.  # noqa: E501

        If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.  # noqa: E501

        :return: The is_lump_sum of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._is_lump_sum

    @is_lump_sum.setter
    def is_lump_sum(self, is_lump_sum):
        """Sets the is_lump_sum of this PositionDto.

        If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.  # noqa: E501

        :param is_lump_sum: The is_lump_sum of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and is_lump_sum is None:
            raise ValueError("Invalid value for `is_lump_sum`, must not be `None`")  # noqa: E501

        self._is_lump_sum = is_lump_sum

    @property
    def repetition_to(self):
        """Gets the repetition_to of this PositionDto.  # noqa: E501

        This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together  # noqa: E501

        :return: The repetition_to of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._repetition_to

    @repetition_to.setter
    def repetition_to(self, repetition_to):
        """Sets the repetition_to of this PositionDto.

        This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together  # noqa: E501

        :param repetition_to: The repetition_to of this PositionDto.  # noqa: E501
        :type: str
        """

        self._repetition_to = repetition_to

    @property
    def standardized_description(self):
        """Gets the standardized_description of this PositionDto.  # noqa: E501

        This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.  # noqa: E501

        :return: The standardized_description of this PositionDto.  # noqa: E501
        :rtype: StandardizedDescriptionDto
        """
        return self._standardized_description

    @standardized_description.setter
    def standardized_description(self, standardized_description):
        """Sets the standardized_description of this PositionDto.

        This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.  # noqa: E501

        :param standardized_description: The standardized_description of this PositionDto.  # noqa: E501
        :type: StandardizedDescriptionDto
        """

        self._standardized_description = standardized_description

    @property
    def complemented_by_quantities(self):
        """Gets the complemented_by_quantities of this PositionDto.  # noqa: E501

        This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.  # noqa: E501

        :return: The complemented_by_quantities of this PositionDto.  # noqa: E501
        :rtype: list[ComplementedByQuantityDto]
        """
        return self._complemented_by_quantities

    @complemented_by_quantities.setter
    def complemented_by_quantities(self, complemented_by_quantities):
        """Sets the complemented_by_quantities of this PositionDto.

        This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.  # noqa: E501

        :param complemented_by_quantities: The complemented_by_quantities of this PositionDto.  # noqa: E501
        :type: list[ComplementedByQuantityDto]
        """

        self._complemented_by_quantities = complemented_by_quantities

    @property
    def execution_description_reference(self):
        """Gets the execution_description_reference of this PositionDto.  # noqa: E501

        This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.  # noqa: E501

        :return: The execution_description_reference of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._execution_description_reference

    @execution_description_reference.setter
    def execution_description_reference(self, execution_description_reference):
        """Sets the execution_description_reference of this PositionDto.

        This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.  # noqa: E501

        :param execution_description_reference: The execution_description_reference of this PositionDto.  # noqa: E501
        :type: str
        """

        self._execution_description_reference = execution_description_reference

    @property
    def not_offered(self):
        """Gets the not_offered of this PositionDto.  # noqa: E501

        This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.  # noqa: E501

        :return: The not_offered of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._not_offered

    @not_offered.setter
    def not_offered(self, not_offered):
        """Sets the not_offered of this PositionDto.

        This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.  # noqa: E501

        :param not_offered: The not_offered of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and not_offered is None:
            raise ValueError("Invalid value for `not_offered`, must not be `None`")  # noqa: E501

        self._not_offered = not_offered

    @property
    def oenorm_position_properties(self):
        """Gets the oenorm_position_properties of this PositionDto.  # noqa: E501

        This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.  # noqa: E501

        :return: The oenorm_position_properties of this PositionDto.  # noqa: E501
        :rtype: OenormPositionPropertiesDto
        """
        return self._oenorm_position_properties

    @oenorm_position_properties.setter
    def oenorm_position_properties(self, oenorm_position_properties):
        """Sets the oenorm_position_properties of this PositionDto.

        This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.  # noqa: E501

        :param oenorm_position_properties: The oenorm_position_properties of this PositionDto.  # noqa: E501
        :type: OenormPositionPropertiesDto
        """

        self._oenorm_position_properties = oenorm_position_properties

    @property
    def description_id(self):
        """Gets the description_id of this PositionDto.  # noqa: E501

        This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.  # noqa: E501

        :return: The description_id of this PositionDto.  # noqa: E501
        :rtype: str
        """
        return self._description_id

    @description_id.setter
    def description_id(self, description_id):
        """Sets the description_id of this PositionDto.

        This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself.  # noqa: E501

        :param description_id: The description_id of this PositionDto.  # noqa: E501
        :type: str
        """

        self._description_id = description_id

    @property
    def hierarchy_level(self):
        """Gets the hierarchy_level of this PositionDto.  # noqa: E501

        This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.  # noqa: E501

        :return: The hierarchy_level of this PositionDto.  # noqa: E501
        :rtype: int
        """
        return self._hierarchy_level

    @hierarchy_level.setter
    def hierarchy_level(self, hierarchy_level):
        """Sets the hierarchy_level of this PositionDto.

        This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.  # noqa: E501

        :param hierarchy_level: The hierarchy_level of this PositionDto.  # noqa: E501
        :type: int
        """
        if self._configuration.client_side_validation and hierarchy_level is None:
            raise ValueError("Invalid value for `hierarchy_level`, must not be `None`")  # noqa: E501

        self._hierarchy_level = hierarchy_level

    @property
    def addendum_status(self):
        """Gets the addendum_status of this PositionDto.  # noqa: E501

        This indicates, if this element is part of an addendum an, if yes, with what status.  # noqa: E501

        :return: The addendum_status of this PositionDto.  # noqa: E501
        :rtype: AddendumStatusDto
        """
        return self._addendum_status

    @addendum_status.setter
    def addendum_status(self, addendum_status):
        """Sets the addendum_status of this PositionDto.

        This indicates, if this element is part of an addendum an, if yes, with what status.  # noqa: E501

        :param addendum_status: The addendum_status of this PositionDto.  # noqa: E501
        :type: AddendumStatusDto
        """

        self._addendum_status = addendum_status

    @property
    def has_bidder_comment_in_html_long_text(self):
        """Gets the has_bidder_comment_in_html_long_text of this PositionDto.  # noqa: E501


        :return: The has_bidder_comment_in_html_long_text of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._has_bidder_comment_in_html_long_text

    @has_bidder_comment_in_html_long_text.setter
    def has_bidder_comment_in_html_long_text(self, has_bidder_comment_in_html_long_text):
        """Sets the has_bidder_comment_in_html_long_text of this PositionDto.


        :param has_bidder_comment_in_html_long_text: The has_bidder_comment_in_html_long_text of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and has_bidder_comment_in_html_long_text is None:
            raise ValueError("Invalid value for `has_bidder_comment_in_html_long_text`, must not be `None`")  # noqa: E501

        self._has_bidder_comment_in_html_long_text = has_bidder_comment_in_html_long_text

    @property
    def gaeb_complementing_type(self):
        """Gets the gaeb_complementing_type of this PositionDto.  # noqa: E501

        This property can optionally be used in GAEB exchange scenarios. It is only meaningful if this position itself is a complementing position, meaning if this position is marked in other positions in their ComplementedBy list. Then, it specifies how the complementing should be expressed in GAEB. By default, positions are always explicitly referenced, but other options are possible. Please also note that the Dangl.AVA.Converter package, which is used for GAEB exports, will check if the given type is valid in the current project configuration. If not, directly referenced positions will be used as fallback.  # noqa: E501

        :return: The gaeb_complementing_type of this PositionDto.  # noqa: E501
        :rtype: PositionComplementingTypeDto
        """
        return self._gaeb_complementing_type

    @gaeb_complementing_type.setter
    def gaeb_complementing_type(self, gaeb_complementing_type):
        """Sets the gaeb_complementing_type of this PositionDto.

        This property can optionally be used in GAEB exchange scenarios. It is only meaningful if this position itself is a complementing position, meaning if this position is marked in other positions in their ComplementedBy list. Then, it specifies how the complementing should be expressed in GAEB. By default, positions are always explicitly referenced, but other options are possible. Please also note that the Dangl.AVA.Converter package, which is used for GAEB exports, will check if the given type is valid in the current project configuration. If not, directly referenced positions will be used as fallback.  # noqa: E501

        :param gaeb_complementing_type: The gaeb_complementing_type of this PositionDto.  # noqa: E501
        :type: PositionComplementingTypeDto
        """
        if self._configuration.client_side_validation and gaeb_complementing_type is None:
            raise ValueError("Invalid value for `gaeb_complementing_type`, must not be `None`")  # noqa: E501

        self._gaeb_complementing_type = gaeb_complementing_type

    @property
    def hold_out_properties(self):
        """Gets the hold_out_properties of this PositionDto.  # noqa: E501

        HoldOut properties describe services that are to be provided and maintained for a specific time, e.g. fences on a construction site.  # noqa: E501

        :return: The hold_out_properties of this PositionDto.  # noqa: E501
        :rtype: PositionHoldOutPropertiesDto
        """
        return self._hold_out_properties

    @hold_out_properties.setter
    def hold_out_properties(self, hold_out_properties):
        """Sets the hold_out_properties of this PositionDto.

        HoldOut properties describe services that are to be provided and maintained for a specific time, e.g. fences on a construction site.  # noqa: E501

        :param hold_out_properties: The hold_out_properties of this PositionDto.  # noqa: E501
        :type: PositionHoldOutPropertiesDto
        """

        self._hold_out_properties = hold_out_properties

    @property
    def estimated_quantity(self):
        """Gets the estimated_quantity of this PositionDto.  # noqa: E501

        This is an informational property, which directly holds a numerical value for an estimated quantity. It is not used for any price calculations.  # noqa: E501

        :return: The estimated_quantity of this PositionDto.  # noqa: E501
        :rtype: float
        """
        return self._estimated_quantity

    @estimated_quantity.setter
    def estimated_quantity(self, estimated_quantity):
        """Sets the estimated_quantity of this PositionDto.

        This is an informational property, which directly holds a numerical value for an estimated quantity. It is not used for any price calculations.  # noqa: E501

        :param estimated_quantity: The estimated_quantity of this PositionDto.  # noqa: E501
        :type: float
        """

        self._estimated_quantity = estimated_quantity

    @property
    def price_catalogue_data(self):
        """Gets the price_catalogue_data of this PositionDto.  # noqa: E501

        This is an optional property that holds price catalogue data. These are prices that may represent an estimate, and they typically come from a price catalogue.  # noqa: E501

        :return: The price_catalogue_data of this PositionDto.  # noqa: E501
        :rtype: PriceCatalogueDataDto
        """
        return self._price_catalogue_data

    @price_catalogue_data.setter
    def price_catalogue_data(self, price_catalogue_data):
        """Sets the price_catalogue_data of this PositionDto.

        This is an optional property that holds price catalogue data. These are prices that may represent an estimate, and they typically come from a price catalogue.  # noqa: E501

        :param price_catalogue_data: The price_catalogue_data of this PositionDto.  # noqa: E501
        :type: PriceCatalogueDataDto
        """

        self._price_catalogue_data = price_catalogue_data

    @property
    def ignore_project_catalogue_propagation(self):
        """Gets the ignore_project_catalogue_propagation of this PositionDto.  # noqa: E501

        If this is set to true, the ProjectCatalogues property will not be propagated to child elements. This is useful in mapping scenarios, where you want to disable propagation for multiple changes, and only enable it once you have mapped all properties.  # noqa: E501

        :return: The ignore_project_catalogue_propagation of this PositionDto.  # noqa: E501
        :rtype: bool
        """
        return self._ignore_project_catalogue_propagation

    @ignore_project_catalogue_propagation.setter
    def ignore_project_catalogue_propagation(self, ignore_project_catalogue_propagation):
        """Sets the ignore_project_catalogue_propagation of this PositionDto.

        If this is set to true, the ProjectCatalogues property will not be propagated to child elements. This is useful in mapping scenarios, where you want to disable propagation for multiple changes, and only enable it once you have mapped all properties.  # noqa: E501

        :param ignore_project_catalogue_propagation: The ignore_project_catalogue_propagation of this PositionDto.  # noqa: E501
        :type: bool
        """
        if self._configuration.client_side_validation and ignore_project_catalogue_propagation is None:
            raise ValueError("Invalid value for `ignore_project_catalogue_propagation`, must not be `None`")  # noqa: E501

        self._ignore_project_catalogue_propagation = ignore_project_catalogue_propagation

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list([x.to_dict() if hasattr(x, "to_dict") else x for x in value])
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict([(item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item for item in list(value.items())])
            else:
                result[attr] = value
        if issubclass(PositionDto, dict):
            for key, value in list(self.items()):
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PositionDto):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, PositionDto):
            return True

        return self.to_dict() != other.to_dict()
